<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grupo REC - PV</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap">
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #f0f4f1;
            color: #333;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
        }

        header {
            background-color: #2e7d32; /* Verde escuro */
            color: white;
            padding: 10px 20px;
            text-align: center;
            border-radius: 5px;
        }

        h1 {
            margin: 10px;
        }

        main {
            margin-top: 20px;
        }

        section {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #ffffff; /* Fundo branco para as seções */
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        h2 {
            color: #388e3c; /* Verde médio */
            border-bottom: 2px solid #2e7d32; /* Linha verde escura */
            padding-bottom: 5px;
        }

        ul {
            margin-left: 20px;
            list-style-type: disc;
        }

        button {
            background-color: #388e3c;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 20px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #106014;
        }

        .page {
            display: none;
        }

        .active {
            display: block;
        }
    </style>
</head>
<body>
    <header>
        <h1>Grupo de Processamento de Vídeo</h1>
        <p>Data: 10 de Outubro de 2024</p>
        <p>Autores: Leonardo Lério, Leandro Scarpi, Willian Gambaro</p>
    </header>

    <div id="home" class="page active">
        <main>
            <h2>Bem-vindo ao Repositório do grupo REC</h2>
            <p>Explore os laboratórios de processamento de vídeo.</p>
            <button onclick="showPage('laboratorio1')">Ir para Laboratório 1</button>
            <button onclick="showPage('laboratorio3')">Ir para Laboratório 3</button><br>
            <button onclick="showPage('laboratorio2')">Ir para Laboratório 2</button>
            <button onclick="showPage('laboratorio4')">Ir para Laboratório 4</button>
            <hr style="border: none; height: 50px;">

            <h2>Confira também o desenvolvimento do trabalho sobre<br>Sistema de Monitoramento de Estacionamento</h2>
            <button onclick="showPage('CA')">1 - Contexto e Cenário de Aplicação</button><br>
            <button onclick="showPage('MF')">2 - Modelagem Funcional  do Sistema de Processamento Visual</button><br>
            <button onclick="showPage('LEx')">3 - Desenvolvimento do Sistema de Processamento Visual</button><br>
            <button onclick="showPage('TC')">4 - Elaboração do Laboratório Experimental</button><br>
            <button onclick="showPage('SPV')">5 - Teste de Campo do SPV</button><br>
            <button onclick="showPage('RFT')">6 - Elaboração do Relatório Final do Trabalho</button><br>
            <button onclick="showPage('DM')">7 - Elaboração de Apresentação – ppt, videos documentais, e demo final</button><br>
            <button onclick="showPage('SEMINAR')">8 - Apresentação no Seminário da Disciplina</button><br>
        </main>
    </div>

    <div id="laboratorio1" class="page">
        <main>
            <h1>Laboratório 1 – Captura de Imagem e Vídeo</h1>
            <section>
                <h2>1 - Introdução</h2>
                <p>Este laboratório visa dar início às atividades com a biblioteca OpenCV, uma ferramenta bastante popular para o tratamento de imagens e vídeos. No decorrer do experimento, exploramos como visualizar e salvar imagens e vídeos, além de aplicar princípios fundamentais de captura e edição de dados visuais. Este relatório registra o procedimento, as técnicas empregadas e os resultados alcançados.</p>
            </section>

            <section>
                <h2>2 - Fundamentos Básicos</h2>
                <p>O OpenCV é um conjunto de ferramentas de visão computacional que possibilita várias operações em imagens e vídeos, tais como leitura, gravação e processamento. Os conceitos fundamentais discutidos incluem:</p>
                <ul>
                    <li>Coleta de Imagens: A ação de extrair uma imagem de um documento ou câmera.</li>
                    <li>Captura de Vídeos: A habilidade de registrar e guardar sequências de imagens num arquivo de vídeo.</li>
                    <li>Edição de Imagens: Modificações básicas, como a conversão de imagens em diversos formatos.</li>
                </ul>
            </section>
            
	    <section>
		<h2>3 - Materiais e Métodos</h2>
		<p>Resultados obtidos na pesquisa.</p>
		<ul>
		    <li>video_read_from_file: Esse programa cria um objeto VideoCapture para o arquivo que está em 'Resources/Cars.mp4', utiliza o método get() para acessar propriedades do vídeo, como frames per second e frame count. Após isso, cria um loop while que roda enquanto o vídeo estiver aberto, inicializa um objeto Mat, que é uma matriz que representa uma imagem e lê as informações do frame para essa matriz. Renderiza o vídeo em uma janela com o método imshow(). No final do loop, há uma condição que verifica se o usuário apertou 'q' para sair do loop, fecha o arquivo de vídeo, todas as janelas e encerra o programa. Pode ser utilizado em programas de reprodução multimídia.</li>
		        
		    <li>video_read_from_image_sequence: Funcionamento quase igual ao 'video_read_from_file', a diferença é que esse lê vários arquivos de imagem, ao invés de um arquivo de vídeo.</li>
		        
		    <li>video_read_from_webcam: Novamente o funcionamento é quase igual, porém agora ao criar o objeto VideoCapture passando o argumento 0, é acessada a câmera padrão do computador. Pode ser utilizado em programas de vídeochamada.</li>
		        
		    <li>video_write_to_file: Esse arquivo lê um vídeo, obtém a largura e altura e cria um objeto VideoWriter utilizando o formato de compressão MJPEG, em que cada frame do vídeo é uma imagem JPEG. Após isso, é iniciado um loop while que mostra cada frame do vídeo e salva cada frame do vídeo no arquivo 'output.avi'.</li>
		        
		    <li>video_write_from_webcam: Funciona de forma parecida com o anterior, a diferença é que ao invés de ler um arquivo de vídeo, lê da webcam. Pode ser utilizado em programas de gravação de vídeos.</li>
		</ul>
		</section>
		
		<section>
		    <h2>4 - Resultados e análises</h2>
		    <p>No decorrer do laboratório, obtivemos:</p>
		    <ul>
		        <li>Registrar e guardar a fotografia de Messi.</li>
		        <li>Efetuar com êxito a leitura e gravação do vídeo, exibindo os quadros.</li>
		        <li>Elaborar imagens e vídeos do grupo, seguindo as diretrizes relativas às cores.</li>
			
			<h1>Vídeo rápido da primeira pessoa</h1>
		<video width="640" height="360" controls>
	    	<source src="lab1/rapido.mp4" type="video/mp4">
	    		</video>
			<h1>Vídeo lento da segunda pessoa</h1>
		<video width="640" height="360" controls>
	    	<source src="lab1/lento.mp4" type="video/mp4">
	    		</video>
			<h1>Vídeo rápido da primeiro objeto</h1>
		<video width="640" height="360" controls>
	    	<source src="lab1/objeto_rapido.mp4" type="video/mp4">
	    		</video>
			<h1>Vídeo lento da segundo objeto</h1>
		<video width="640" height="360" controls>
	    	<source src="lab1/objeto_lento.mp4" type="video/mp4">
			</video>
			<h1>Imagem do grupo</h1>
	    <img src="lab1/FotoGrupo.jpg" alt="Descrição da Imagem" width="300" height="200">
	    		<h1>Foto Montagem</h1>
	    <img src="lab1/FotoMontagem.jpeg" alt="Descrição da Imagem" width="300" height="200">
		    </ul>
		</section>

	      <section>
		    <h2>5 - Conclusões e comentários finais</h2>
		    <p>Este laboratório ofereceu uma experiência prática com o OpenCV, facilitando a compreensão dos princípios básicos do processamento de imagem e vídeo. A vivência com a captura e análise de dados visuais evidenciou a flexibilidade da biblioteca. Ademais, a criação de imagens através do Canva foi um acréscimo interessante, que nos possibilitou explorar a criatividade na apresentação dos resultados.</p>
		    <p>No futuro, poderemos expandir nossos estudos em processamento de vídeo, investigando métodos mais sofisticados e suas utilizações práticas.</p>
	     </section>

            <button onclick="showPage('home')">Voltar para a Página Inicial</button>
        </main>
    </div>

    <div id="laboratorio2" class="page">
        <main>
            <h1>Laboratório 2 – Análise de Vídeo</h1>
            <section>
                <h2>1 - Introdução</h2>
                <p>O tratamento de imagens é um campo crucial na visão computacional, focado na manipulação e avaliação de imagens digitais. Neste estudo, recorremos à biblioteca OpenCV para implementar diversas técnicas de filtragem em imagens, com o objetivo de diminuir ruídos e aprimorar a qualidade da imagem. A filtragem é um procedimento que modifica os pixels de uma imagem para alcançar um propósito específico, como suavizar ou destacar atributos. Neste trabalho, nos concentraremos em filtros como média, gaussiana, mediana e bilateral, investigando o impacto do tamanho do núcleo nas imagens processadas.</p>
            </section>
            <section>
                <h2>2 - Fundamentos Básicos</h2>
                <p>Os filtros de imagem são instrumentos fundamentais na manipulação de imagens. Cada tipo de filtro tem atributos que o qualificam para diversas utilizações:
		<ul>
		    <li>Filtro de Média: Diminui ruídos através da suavização da imagem, substituindo cada pixel pela média dos pixels adjacentes. É eficiente, porém pode provocar manchas.
		    <li>Filtro Gaussiano: Comparado ao filtro de média, atribui maior importância aos pixels próximos, o que resulta em uma suavização mais suave e menos desfocada.
		    <li>Filtro Mediano: Repõe cada pixel com o valor mediano dos pixels adjacentes. É particularmente eficiente na eliminação do ruído de sal e pimenta, mantendo as bordas intactas.
		    <li>Filtro Bilateral: Integra suavização e manutenção das bordas, levando em conta tanto a proximidade espacial quanto a semelhança de cor dos pixels.
		
		
		<ul>

</p>
            </section>
            <section>
                <h2>3 - Materiais e Métodos</h2>
                <p>
                <ul>
		    <li>Fotografias: Usaremos fotografias feitas durante o Laboratório 1.
		    <li>Análise: Desenvolvimento de softwares para a aplicação dos filtros de média, gaussiano, mediano e bilateral, empregando kernels de dimensões 3x3, 5x5, 7x7 e 11x11.
Cada resultado será armazenado em pastas separadas, categorizadas de acordo com o tipo de filtro e o tamanho do kernel.
		    <li>Sal e Pimenta: Incorporaremos o ruído sal-e-pimenta às imagens originais e repetimos o procedimento de filtragem, examinando a reação de cada filtro ao ruído.
		    <li>Processamento em Tempo Real: Uma aplicação extra usará a entrada da webcam, exibindo os resultados da filtragem em uma janela OpenCV.
A imagem poderá ser salva ao pressionar a tecla [s].
		    <li>Desafio de Escolha: Um aplicativo interativo possibilitará ao usuário selecionar o tipo de filtragem e a dimensão do kernel.</p>
                <ul>
            </section>
            <section>
                <h2>4 - Resultados e Análises</h2>
                <p>Os dados foram estruturados em diagramas que apresentam a comparação visual entre as imagens filtradas para variados tamanhos de kernel e métodos de filtragem. Examinamos como a mudança no tamanho do kernel influencia a suavização e a manutenção de detalhes nas fotografias. Adicionalmente, analisamos a efetividade de cada tipo de filtro na gestão do ruído sal-e-pimenta. Comparamos as imagens filtradas, ressaltando os benefícios e desvantagens de cada técnica.Para a filtragem em tempo real, avaliamos a habilidade do sistema em interpretar a entrada da webcam e implementar as filtragens selecionadas, avaliando a latência e a qualidade das imagens armazenadas.</p>
                <h1>Parte 1</h1>
                <h3>kernel 3x3</h3>
                <h4>bilateral Blur</h4>
	    <img src="lab2/1/kernel3x3/results/bilateral_blur_image_kernel3x3.jpg" alt="Descrição da Imagem" width="300" height="200">
	        <h4>Gaussian Blur</h4>
	    <img src="lab2/1/kernel3x3/results/gaussian_blur_image_kernel3x3.jpg" alt="Descrição da Imagem" width="300" height="200">
	        <h4>Madian Blur</h4>
	    <img src="lab2/1/kernel3x3/results/median_blur_image_kernel3x3.jpg" alt="Descrição da Imagem" width="300" height="200">
	        <h4>Blur</h4>
	    <img src="lab2/1/kernel3x3/results/blur_image_kernel3x3.jpg" alt="Descrição da Imagem" width="300" height="200">
	    
	    	<h3>kernel 5x5</h3>
                <h4>bilateral Blur</h4>
	    <img src="lab2/1/kernel5x5/results/bilateral_blur_image_kernel5x5.jpg" alt="Descrição da Imagem" width="300" height="200">
	        <h4>Gaussian Blur</h4>
	    <img src="lab2/1/kernel5x5/results/gaussian_blur_image_kernel5x5.jpg" alt="Descrição da Imagem" width="300" height="200">
	        <h4>Madian Blur</h4>
	    <img src="lab2/1/kernel5x5/results/median_blur_image_kernel5x5.jpg" alt="Descrição da Imagem" width="300" height="200">
	        <h4>Blur</h4>
	    <img src="lab2/1/kernel5x5/results/blur_image_kernel5x5.jpg" alt="Descrição da Imagem" width="300" height="200">
	    
	    	<h3>kernel 7x7</h3>
                <h4>bilateral Blur</h4>
	    <img src="lab2/1/kernel7x7/results/bilateral_blur_image_kernel7x7.jpg" alt="Descrição da Imagem" width="300" height="200">
	        <h4>Gaussian Blur</h4>
	    <img src="lab2/1/kernel7x7/results/gaussian_blur_image_kernel7x7.jpg" alt="Descrição da Imagem" width="300" height="200">
	        <h4>Madian Blur</h4>
	    <img src="lab2/1/kernel7x7/results/median_blur_image_kernel7x7.jpg" alt="Descrição da Imagem" width="300" height="200">
	        <h4>Blur</h4>
	    <img src="lab2/1/kernel7x7/results/blur_image_kernel7x7.jpg" alt="Descrição da Imagem" width="300" height="200">
	    
	    	<h3>kernel 11x11</h3>
                <h4>bilateral Blur</h4>
	    <img src="lab2/1/kernel11x11/results/bilateral_blur_image_kernel11x11.jpg" alt="Descrição da Imagem" width="300" height="200">
	        <h4>Gaussian Blur</h4>
	    <img src="lab2/1/kernel11x11/results/gaussian_blur_image_kernel11x11.jpg" alt="Descrição da Imagem" width="300" height="200">
	        <h4>Madian Blur</h4>
	    <img src="lab2/1/kernel11x11/results/median_blur_image_kernel11x11.jpg" alt="Descrição da Imagem" width="300" height="200">
	        <h4>Blur</h4>
	    <img src="lab2/1/kernel11x11/results/blur_image_kernel11x11.jpg" alt="Descrição da Imagem" width="300" height="200">
	         
	       <h1>Parte 2</h1>
	       <img src="lab2/2/sal_pimenta/results/salt_pepper_noise_image.jpg" alt="Descrição da Imagem" width="300" height="200">
            	       
		    
		<h1>Parte 3</h1>
	       <h3>Programa em que a imagem de entrada é da webcam, e que mostre o resultado da filtragem numa janela opencv, de forma contínua na tela do computar. Utilizando a tecla [s] do teclado para permitir salvar a imagem sendo apresentada na tela, em formato .jpg.</h3>
		<pre><code>
#include &lt;iostream&gt;
#include &lt;opencv2/imgproc/imgproc.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;
#include &lt;opencv2/core/core.hpp&gt;

using namespace std;
using namespace cv;

void add_salt_pepper_noise(Mat &srcArr, float pa, float pb )
{    
    RNG rng; // rand number generator
    int amount1=srcArr.rows*srcArr.cols*pa;
    int amount2=srcArr.rows*srcArr.cols*pb;
    for(int counter=0; counter&lt;amount1; ++counter)
    {
        srcArr.at&lt;uchar&gt;(rng.uniform( 0,srcArr.rows), rng.uniform(0, srcArr.cols)) =0;
    }
    for (int counter=0; counter&lt;amount2; ++counter)
    {
        srcArr.at&lt;uchar&gt;(rng.uniform(0,srcArr.rows), rng.uniform(0, srcArr.cols)) = 255;
    }
}

int main(int argc, char* argv[]) {
    Mat srcArr;
    
    if (argc &lt;= 1) {
        srcArr = imread("image.jpg");
    } else if (argc &gt;= 2) {
        srcArr = imread(argv[1]);
    }
    
    cvtColor(srcArr, srcArr, COLOR_RGB2GRAY, 1);
    
    float pa = 0.02;
    float pb = 0.02;
    
    add_salt_pepper_noise(srcArr, pa, pb);
    
    imwrite("salt_pepper_noise_image.jpg", srcArr);
    
    printf("\nFiltro sal e pimenta aplicado na imagem!");
    printf("\nImagem salva\n\n");
}
</code></pre>	       

      
	       <h1>Parte 4 - Desafio</h1>
               <h3>Programa de filtragem para entrada webcam, e que mostre o resultado da filtragem numa janela opencv, sendo que permitirá ao usuário escolher o tipo de filtragem, e o tamanho do kernel.</h3>
	     <pre><code>  
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

// Função para aplicar o filtro baseado na escolha do usuário
Mat applyFilter(const Mat& frame, int filterType, int kernelSize) {
    Mat filteredFrame;
    
    // Escolhe o filtro baseado na entrada
    switch (filterType) {
        case 0: // Filtro de média
            blur(frame, filteredFrame, Size(kernelSize, kernelSize));
            break;
        case 1: // Filtro gaussiano
            GaussianBlur(frame, filteredFrame, Size(kernelSize, kernelSize), 0);
            break;
        case 2: // Filtro mediano
            medianBlur(frame, filteredFrame, kernelSize);
            break;
        case 3: // Filtro bilateral
            bilateralFilter(frame, filteredFrame, kernelSize, kernelSize * 2, kernelSize / 2);
            break;
        default:
            filteredFrame = frame; // Sem filtro
            break;
    }
    return filteredFrame;
}

int main() {
    VideoCapture cap(0); // Captura da webcam
    if (!cap.isOpened()) {
        cerr << "Erro ao abrir a webcam!" << endl;
        return -1;
    }

    int filterType = 0; // Tipo de filtro (0: média, 1: gaussiano, 2: mediano, 3: bilateral)
    int kernelSize = 3; // Tamanho do kernel

    while (true) {
        Mat frame;
        cap >> frame; // Captura um novo frame

        // Aplica o filtro
        Mat filteredFrame = applyFilter(frame, filterType, kernelSize);

        // Exibe o frame filtrado
        imshow("Video Filtrado", filteredFrame);

        // Teclas de controle
        char key = (char)waitKey(30);
        if (key == 27) { // Tecla ESC para sair
            break;
        } else if (key == 'a') {
            filterType = 0; // Filtro de média
        } else if (key == 'g') {
            filterType = 1; // Filtro gaussiano
        } else if (key == 'm') {
            filterType = 2; // Filtro mediano
        } else if (key == 'b') {
            filterType = 3; // Filtro bilateral
        } else if (key == '3') {
            kernelSize = 3;
        } else if (key == '5') {
            kernelSize = 5;
        } else if (key == '7') {
            kernelSize = 7;
        } else if (key == '9') {
            kernelSize = 9;
        } else if (key == 'B') {
            kernelSize = 11;
        }

        // Ajusta o kernelSize para ser ímpar
        if (kernelSize % 2 == 0) {
            kernelSize += 1;
        }
    }

    cap.release(); // Libera a captura
    destroyAllWindows(); // Fecha todas as janelas
    return 0;
}
             </code></pre>   
	  
            </section>
            <section>
                <h2>5 - Conclusões e Comentários Finais</h2>
                <p>Este experimento ofereceu uma visão prática dos variados tipos de filtragem em imagens. Notamos que a seleção do filtro e a dimensão do kernel influenciam consideravelmente a qualidade final da imagem. Os filtros mediano e bilateral se mostraram mais eficientes em preservar detalhes relevantes enquanto minimizavam ruídos, particularmente em circunstâncias onde o ruído sal-e-pimenta estava presente.

O teste de filtragem em tempo real evidenciou a capacidade da OpenCV em aplicações interativas, ressaltando a relevância do tratamento de imagens em tempo real em campos como a vigilância e a comunicação visual. No futuro, poderemos investigar algoritmos mais sofisticados e utilizações em cenários mais intrincados, como a análise de vídeo e o reconhecimento de padrões.</p>
            </section>
            <button onclick="showPage('home')">Voltar para a Página Inicial</button>
        </main>
    </div>

    <div id="laboratorio3" class="page">
        <main>
            <h1>Laboratório 3 – Espaço de Cores</h1>
            <section>
                <h2>1 - Introdução</h2>
                <p>Este laboratório visa dar início às atividades com a biblioteca OpenCV, uma ferramenta bastante popular para o tratamento de imagens e vídeos. No decorrer do experimento, exploramos como visualizar e salvar imagens e vídeos, além de aplicar princípios fundamentais de captura e edição de dados visuais. Este relatório registra o procedimento, as técnicas empregadas e os resultados alcançados.</p>
            </section>

            <section>
                <h2>2 - Fundamentos Básicos</h2>
                <p>O OpenCV é um conjunto de ferramentas de visão computacional que possibilita várias operações em imagens e vídeos, tais como leitura, gravação e processamento. Os conceitos fundamentais discutidos incluem:</p>
                <ul>
                    <li>Coleta de Imagens: A ação de extrair uma imagem de um documento ou câmera.</li>
                    <li>Captura de Vídeos: A habilidade de registrar e guardar sequências de imagens num arquivo de vídeo.</li>
                    <li>Edição de Imagens: Modificações básicas, como a conversão de imagens em diversos formatos.</li>
                </ul>
            </section>
            
	    <section>
		<h2>3 - Materiais e Métodos</h2>
		<p>Resultados obtidos na pesquisa.</p>
		<ul>
		    <li>video_read_from_file: Esse programa cria um objeto VideoCapture para o arquivo que está em 'Resources/Cars.mp4', utiliza o método get() para acessar propriedades do vídeo, como frames per second e frame count. Após isso, cria um loop while que roda enquanto o vídeo estiver aberto, inicializa um objeto Mat, que é uma matriz que representa uma imagem e lê as informações do frame para essa matriz. Renderiza o vídeo em uma janela com o método imshow(). No final do loop, há uma condição que verifica se o usuário apertou 'q' para sair do loop, fecha o arquivo de vídeo, todas as janelas e encerra o programa. Pode ser utilizado em programas de reprodução multimídia.</li>
		        
		    <li>video_read_from_image_sequence: Funcionamento quase igual ao 'video_read_from_file', a diferença é que esse lê vários arquivos de imagem, ao invés de um arquivo de vídeo.</li>
		        
		    <li>video_read_from_webcam: Novamente o funcionamento é quase igual, porém agora ao criar o objeto VideoCapture passando o argumento 0, é acessada a câmera padrão do computador. Pode ser utilizado em programas de vídeochamada.</li>
		        
		    <li>video_write_to_file: Esse arquivo lê um vídeo, obtém a largura e altura e cria um objeto VideoWriter utilizando o formato de compressão MJPEG, em que cada frame do vídeo é uma imagem JPEG. Após isso, é iniciado um loop while que mostra cada frame do vídeo e salva cada frame do vídeo no arquivo 'output.avi'.</li>
		        
		    <li>video_write_from_webcam: Funciona de forma parecida com o anterior, a diferença é que ao invés de ler um arquivo de vídeo, lê da webcam. Pode ser utilizado em programas de gravação de vídeos.</li>
		</ul>
		</section>
		
		<section>
		    <h2>4 - Resultados e análises</h2>
		    <p>No decorrer do laboratório, obtivemos:</p>
		    <ul>
		        <li>Registrar e guardar a fotografia de Messi.</li>
		        <li>Efetuar com êxito a leitura e gravação do vídeo, exibindo os quadros.</li>
		        <li>Elaborar imagens e vídeos do grupo, seguindo as diretrizes relativas às cores.</li>
			
			<h1>Vídeo rápido da primeira pessoa</h1>
		<video width="640" height="360" controls>
	    	<source src="lab1/rapido.mp4" type="video/mp4">
	    		</video>
			<h1>Vídeo lento da segunda pessoa</h1>
		<video width="640" height="360" controls>
	    	<source src="lab1/lento.mp4" type="video/mp4">
	    		</video>
			<h1>Vídeo rápido da primeiro objeto</h1>
		<video width="640" height="360" controls>
	    	<source src="lab1/objeto_rapido.mp4" type="video/mp4">
	    		</video>
			<h1>Vídeo lento da segundo objeto</h1>
		<video width="640" height="360" controls>
	    	<source src="lab1/objeto_lento.mp4" type="video/mp4">
			</video>
			<h1>Imagem do grupo</h1>
	    <img src="lab1/FotoGrupo.jpg" alt="Descrição da Imagem" width="300" height="200">
	    		<h1>Foto Montagem</h1>
	    <img src="lab1/FotoMontagem.jpeg" alt="Descrição da Imagem" width="300" height="200">
		    </ul>
		</section>

	      <section>
		    <h2>5 - Conclusões e comentários finais</h2>
		    <p>Este laboratório ofereceu uma experiência prática com o OpenCV, facilitando a compreensão dos princípios básicos do processamento de imagem e vídeo. A vivência com a captura e análise de dados visuais evidenciou a flexibilidade da biblioteca. Ademais, a criação de imagens através do Canva foi um acréscimo interessante, que nos possibilitou explorar a criatividade na apresentação dos resultados.</p>
		    <p>No futuro, poderemos expandir nossos estudos em processamento de vídeo, investigando métodos mais sofisticados e suas utilizações práticas.</p>
	     </section>

            <button onclick="showPage('home')">Voltar para a Página Inicial</button>
        </main>
    </div>

    <div id="laboratorio4" class="page">
        <main>
            <h1>Laboratório 4 – Espaço de Cores</h1>
            <section>
                <h2>1 - Introdução</h2>
                <p>Este experimento tem como objetivo explorar o processamento de imagens, especificamente o cálculo e equalização de histogramas, a limiarização (binarização) e a equalização em imagens coloridas. Essas técnicas são amplamente usadas em visão computacional para melhorar a qualidade de imagens, realçar características e preparar dados para análises subsequentes.</p>
            </section>

            <section>
                <h2>2 - Fundamentos Básicos</h2>
                <p>Para realizar o experimento, é essencial entender os seguintes conceitos:</p>
                <ul>
                    <li>Histograma de Imagens: Distribuição de intensidade de pixels em uma imagem. É utilizado para representar a quantidade de pixels em cada nível de cinza ou em cada cor, fornecendo informações sobre o contraste e brilho.</li>
                    <li>Equalização de Histograma: Técnica para ajustar o contraste de uma imagem ao redistribuir as intensidades dos pixels, o que resulta em uma imagem com melhor distribuição de tons.</li>
                    <li>Limiarização (Binarização): Processo de converter uma imagem em tons de cinza para uma imagem binária, onde os pixels são classificados como preto ou branco com base em um limiar de intensidade.</li>
                </ul>
                <p>Esses conceitos foram estudados e implementados conforme as orientações nos tutoriais do OpenCV.</p>
            </section>
            
	    <section>
		<h2>3 - Materiais e Métodos</h2>
		<p>Os experimentos foram conduzidos usando a linguagem C++ com a biblioteca OpenCV. Os passos foram os seguintes:</p>
		<ul>
		    <li>a) Leitura e Processamento de Imagem: Um programa foi desenvolvido para ler uma imagem e convertê-la para tons de cinza. O histograma da imagem foi calculado e equalizado, e os resultados foram salvos como imagens de saída e gráficos de histograma.</li>
		        
		    <li>b) Processamento de Imagem da Webcam: Modificações no código original permitiram o processamento de uma imagem capturada em tempo real pela webcam. O programa exibe a imagem em tons de cinza e equalizada ao vivo.</li>
		        
		    <li>c) Binarização de Imagens: video_read_from_webcam: Novamente o funcionamento é quase igual, porém agora ao criar o objeto VideoCapture passando o argumento 0, é acessada a câmera padrão do computador. Pode ser utilizado em programas de vídeochamada.</li>
		        
		    <li>d) Equalização em Imagens Coloridas: video_write_to_file: Esse arquivo lê um vídeo, obtém a largura e altura e cria um objeto VideoWriter utilizando o formato de compressão MJPEG, em que cada frame do vídeo é uma imagem JPEG. Após isso, é iniciado um loop while que mostra cada frame do vídeo e salva cada frame do vídeo no arquivo 'output.avi'.</li>
		        
		</ul>
		</section>
		
		<section>
		    <h2>4 - Resultados e análises</h2>
		    <p>Os resultados indicaram que:</p>
		    <ul>
		        <li>Equalização de Histograma: A equalização resultou em uma imagem com contraste significativamente melhorado, especialmente em imagens com pouca variação de intensidade.</li>
		        <li>Limiarização: A aplicação da binarização após a equalização produziu uma imagem binária mais nítida e com maior destaque dos detalhes.</li>
		        <li>Elaborar imagens e vídeos do grupo, seguindo as diretrizes relativas às cores.</li>
			
                
		    </ul>
		</section>

	      <section>
		    <h2>5 - Conclusões e comentários finais</h2>
		    <p>As técnicas de histogramas e limiarização são eficazes para manipulação e realce de imagens. A equalização trouxe melhorias notáveis no contraste e foi essencial para a binarização eficaz. Em imagens coloridas, a equalização separada dos canais aprimorou a vivacidade e clareza. Esse conjunto de técnicas é altamente aplicável em tarefas de visão computacional, onde a definição de contrastes é crucial.</p>
	     </section>

            <button onclick="showPage('home')">Voltar para a Página Inicial</button>
        </main>
    </div>

    <script>
        function showPage(pageId) {
            // Esconder todas as páginas
            const pages = document.querySelectorAll('.page');
            pages.forEach(page => {
                page.classList.remove('active');
            });

            // Mostrar a página selecionada
            const activePage = document.getElementById(pageId);
            activePage.classList.add('active');
        }
    </script>
</body>
</html>
